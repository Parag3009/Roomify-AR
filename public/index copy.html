<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        /* Position the buttons in the upper right-hand corner */
        #scale-up-button,
        #scale-down-button {
            position: absolute;
            top: 40px;
            right: 30px;
        }
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <!-- <div id="content">
      <div id="mySidenav" class="sidenav">
          <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
          <a class="ar-object" id="1" href="#"><img src="./pics/1.png" alt="" style="width: 90px;"></a>
          <a class="ar-object" id="2" href="#">Item_2</a>
          <a class="ar-object" id="3" href="#">Item_3</a>
          <a class="ar-object" id="4" href="#">Item_4</a>
          <a class="ar-object" id="5" href="#">Item_5</a>
          <a class="ar-object" id="7" href="#">Item_7</a>
      </div>
      <div id="container" style="position: fixed;"></div>
      <span style="font-size:30px;cursor:pointer; position: absolute;" onclick="openNav()">&#9776; open</span>
      <button type="button" id="place-button" style="display:none">PLACE</button>
      <button type="button" id="scale-up-button" style="display:none">Scale Up</button>
      <button type="button" id="scale-down-button" style="display:none">Scale Down</button>
  </div> -->
  <!-- <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - hit test<br/>(Chrome Android 81+)
  </div> -->
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
      {
          "imports": {
              "three": "./build/three.module.js",
              "three/addons/": "./jsm/"
          }
      }
  </script>
  <!-- <script>
      function openNav() {
          document.getElementById("mySidenav").style.width = "250px";
      }

      function closeNav() {
          document.getElementById("mySidenav").style.width = "0";
      }
  </script> -->
  <script type="module">
      import * as THREE from 'three';
      import { ARButton } from 'three/addons/webxr/ARButton.js';
      import { OrbitControls } from './jsm/controls/OrbitControls.js';
      import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
      import { RGBELoader } from './jsm/loaders/RGBELoader.js';

      let container;
      let camera, scene, renderer;
      let controller;

      let reticle, pmremGenerator, current_object, controls;

      let hitTestSource = null;
      let hitTestSourceRequested = false;

      // Array to store placed models
      const placedModels = [];

      // Function to add a placed model to the scene
      function addPlacedModel(model) {
          const clonedModel = model.clone(); // Clone the selected 3D model
          scene.add(clonedModel); // Add the cloned model to the scene
          placedModels.push({
              object: clonedModel,
              scale: 1.0 // Initial scale
          }); // Store a reference to the placed model
      }

      // Function to handle model selection
      $(".ar-object").click(function () {
          const modelId = $(this).attr("id");
          if (current_object != null) {
              scene.remove(current_object);
          }
          loadModel(modelId);
      });

      // Modify arPlace function to take a model as a parameter and set its position, rotation, and scale based on the reticle
      function arPlace(model, scale) {
          if (reticle.visible) {
              model.position.setFromMatrixPosition(reticle.matrix);
              
              // Set the rotation of the model to match the rotation of the reticle
              model.rotation.setFromRotationMatrix(reticle.matrix);
              
              // Set the scale of the model
              model.scale.set(scale, scale, scale);
              
              model.visible = true; // Ensure the model is visible after placement
          }
      }

      // Modify your "PLACE" button click event to add the current model to the scene
      $("#place-button").click(function () {
          if (current_object) {
              // Check if reticle is visible before placing the model
              if (reticle.visible) {
                  const scale = placedModels.length > 0 ? placedModels[placedModels.length - 1].scale : 1.0;
                  addPlacedModel(current_object, scale);
                  current_object = null; // Clear the current object after placing
              }
          }
      });

      // Function to update the rotation of all placed models
      function rotateAllPlacedModels() {
          for (const { object } of placedModels) {
              if (object && reticle.visible) {
                  object.rotation.y += deltaX / 100;
              }
          }
      }

      // Function to scale up the current placed model
      $("#scale-up-button").click(function () {
          if (placedModels.length > 0) {
              const { object, scale } = placedModels[placedModels.length - 1];
              const newScale = scale * 1.5; // You can adjust the scaling factor
              object.scale.set(newScale, newScale, newScale);
          }
      });

      // Function to scale down the current placed model
      $("#scale-down-button").click(function () {
          if (placedModels.length > 0) {
              const { object, scale } = placedModels[placedModels.length - 1];
              const newScale = scale / 1.5; // You can adjust the scaling factor
              object.scale.set(newScale, newScale, newScale);
          }
      });

      function loadModel(model) {
          new RGBELoader()
              .setDataType(THREE.FloatType)
              .setPath('textures/')
              .load('photo_studio_01_1k.hdr', function (texture) {
                  let envmap = pmremGenerator.fromEquirectangular(texture).texture;
                  scene.environment = envmap;
                  texture.dispose();
                  pmremGenerator.dispose();
                  render();

                  let loader = new GLTFLoader().setPath('3d/');
                  loader.load(model + ".glb", function (glb) {
                      current_object = glb.scene;
                      arPlace(current_object, 1.0);
                      var box = new THREE.Box3();
                      box.setFromObject(current_object);
                      box.center(controls.target);
                      controls.update();
                      render();
                  });
              });
      }

      function init() {
          container = document.createElement('div');
          document.getElementById("container").appendChild(container);
          scene = new THREE.Scene();
          camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
          var directionalLight = new THREE.DirectionalLight(0xdddddd, 1);
          directionalLight.position.set(0, 0, 1).normalize();
          scene.add(directionalLight);
          var ambientLight = new THREE.AmbientLight(0x222222);
          scene.add(ambientLight);

          renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.xr.enabled = true;
          container.appendChild(renderer.domElement);

          pmremGenerator = new THREE.PMREMGenerator(renderer);
          pmremGenerator.compileEquirectangularShader();

          controls = new OrbitControls(camera, renderer.domElement);
          controls.addEventListener('change', render);
          controls.minDistance = 2;
          controls.maxDistance = 10;
          controls.target.set(0, 0, -0.2);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;

          let options = {
              requiredFeatures: ['hit-test'],
              optionalFeatures: ['dom-overlay'],
          }

          options.domOverlay = { root: document.getElementById('content') };

          document.body.appendChild(ARButton.createButton(renderer, options));

          reticle = new THREE.Mesh(
              new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
              new THREE.MeshBasicMaterial()
          );
          reticle.matrixAutoUpdate = false;
          reticle.visible = false;
          scene.add(reticle);

          window.addEventListener('resize', onWindowResize);

          renderer.domElement.addEventListener('touchstart', function (e) {
              e.preventDefault();
              touchDown = true;
              touchX = e.touches[0].pageX;
              touchY = e.touches[0].pageY;
          }, false);

          renderer.domElement.addEventListener('touchend', function (e) {
              e.preventDefault();
              touchDown = false;
          }, false);

          renderer.domElement.addEventListener('touchmove', function (e) {
              e.preventDefault();
              if (!touchDown) {
                  return;
              }
              deltaX = e.touches[0].pageX - touchX;
              deltaY = e.touches[0].pageY - touchY;
              touchX = e.touches[0].pageX;
              touchY = e.touches[0].pageY;
              rotateAllPlacedModels();
          }, false);
      }

      var touchDown, touchX, touchY, deltaX, deltaY;

      function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
          renderer.setAnimationLoop(render);
          requestAnimationFrame(animate);
          controls.update();
      }

      function render(timestamp, frame) {
          if (frame) {
              const referenceSpace = renderer.xr.getReferenceSpace();
              const session = renderer.xr.getSession();

              if (hitTestSourceRequested === false) {
                  session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                      session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                          hitTestSource = source;
                      });
                  });

                  session.addEventListener('end', function () {
                      hitTestSourceRequested = false;
                      hitTestSource = null;
                      reticle.visible = false;
                      document.getElementById("place-button").style.display = "none";
                      document.getElementById("scale-up-button").style.display = "none";
                      document.getElementById("scale-down-button").style.display = "none";
                  });

                  hitTestSourceRequested = true;
              }

              if (hitTestSource) {
                  const hitTestResults = frame.getHitTestResults(hitTestSource);

                  if (hitTestResults.length) {
                      var hit = hitTestResults[0];
                      document.getElementById("place-button").style.display = "block";
                      document.getElementById("scale-up-button").style.display = "block";
                      document.getElementById("scale-down-button").style.display = "block";
                      reticle.visible = true;
                      reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                  } else {
                      reticle.visible = false;
                      document.getElementById("place-button").style.display = "none";
                      document.getElementById("scale-up-button").style.display = "none";
                      document.getElementById("scale-down-button").style.display = "none";
                  }
              }
          }

          renderer.render(scene, camera);
      }

      init();
      animate();
  </script>
    <!-- <noscript>You need to enable JavaScript to run this app.</noscript> -->
    <!-- <div id="root"></div> -->
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
